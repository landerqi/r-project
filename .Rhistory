set.seed(1)
vec <- round(runif(12) * 100)
mat <- matrix(vec, 3, 4)
mat
vec <- round(runif(12) * 100)
mat <- matrix(vec, 3, 4)
mat
apply(mat, 1, sum)
apply(mat, 2, sum)
apply(mat, 2, function(x) max(x) - min(x))
mylist <- as.list(iris[ ,1:4])
class(mylist)
# 处理list 和sapply非常相似
lapply(mylist, mean)
sapply(iris[ ,1:4], function(x) sd(x) / mean(x))
# 变异系数
options(digits = 0) # 更改小数位数
sapply(iris[ ,1:4], function(x) sd(x) / mean(x))
# 变异系数
options(digits = 10) # 更改小数位数
sapply(iris[ ,1:4], function(x) sd(x) / mean(x))
tapply(X = iris$Sepal.Length, INDEX = list(iris$Species), FUN = mean)
iris
tapply(X = iris$Sepal.Length, INDEX = list(iris$Species), FUN = mean)
with(iris, tapply(Sepal.Length, list(Species) , mean))
with(iris, aggregate(Sepal.Length, list(Species) , mean))
class(with(iris, tapply(Sepal.Length, list(Species) , mean)))
with(iris, tapply(Sepal.Length, list(Species) , mean))
class(with(iris, aggregate(Sepal.Length, list(Species) , mean)))
vec1 <- vec2 <- 1:9
para <- expand.grid(vec1, vec2)
para
res <- mapply(FUN = prod, para[ ,1], para[ ,2])
res
# 如果只处理两个参数，可以使用 outer
outer(vec1, vec2, FUN = '*')
# 如果只处理两个参数，可以使用 outer
class(outer(vec1, vec2, FUN = '*'))
# 如果只处理两个参数，可以使用 outer
outer(vec1, vec2, FUN = '*')
# 如果只处理两个参数，可以使用 outer
outer(vec1, vec2, FUN = prod)
# 如果只处理两个参数，可以使用 outer
outer(vec1, vec2, '*')
outer(vec1, vec2, FUN = MyFunc2)
return(ret)
MyFunc2 <- function(x, y) {
left <- paste0(x, '*', y, '=')
right <- x*y
ret <- paste0(left, right)
return(ret)
}
outer(vec1, vec2, FUN = MyFunc2)
ret <- paste(left, right)
return(ret)
MyFunc2 <- function(x, y) {
left <- paste(x, '*', y, '=')
right <- x*y
ret <- paste(left, right)
return(ret)
}
outer(vec1, vec2, FUN = MyFunc2)
return(ret)
MyFunc2 <- function(x, y) {
left <- paste0(x, '*', y, '=')
right <- x*y
ret <- paste0(left, right)
return(ret)
}
outer(vec1, vec2, FUN = MyFunc2)
?paste0
nth <- paste0(1:12, c("st", "nd", "rd", rep("th", 9)))
nth
nth <- paste(1:12, c("st", "nd", "rd", rep("th", 9)))
nth
nth <- paste(1:12, c("st", "nd", "rd", rep("th", 9)), collapse = ', ')
nth
nth <- paste(1:12, c("st", "nd", "rd", rep("th", 9)))
nth
nth <- paste0(1:12, c("st", "nd", "rd", rep("th", 9)), collapse = ', ')
nth
nth <- paste0(1:12, c("st", "nd", "rd", rep("th", 9)))
nth
# replicate函数能让某个函数重复调用多遍， 这在统计中非常有用。例如生成1000个服从正态分布的随机向量，
# 然后计算其均值， 并使这个过程重复100遍
res <- replicate(100, mean(rnorm(1000)))
res
# replicate函数能让某个函数重复调用多遍， 这在统计中非常有用。例如生成1000个服从正态分布的随机向量，
# 然后计算其均值， 并使这个过程重复100遍
res <- replicate(100, mean(rnorm(10000)))
res
plot(rnorm(1))
plot(rnorm(1))
plot(rnorm(10000))
plot(rnorm(100))
curve(rnorm(100))
curve(rnorm(100))
plot(rnorm(100))
plot(rnorm(1000))
plot(rnorm(100000))
plot(rnorm(10000))
plot(rnorm(5000))
res
plot(res)
curve(res)
curve(mean(rnorm(1000)))
?rnorm
res <- rnorm(100)
res
# 一个求圆面积的函数
MyFunc <- function(r) {
area <- pi*r^2
return(area)
}
print(MyFunc(4))
#条件判断---顺序执行
num <- 5
if (num %% 2 != 0) {
cat(num, 'is odd')
}
#条件判断---顺序执行
num <- 6
if (num %% 2 != 0) {
cat(num, 'is odd')
} else {
cat(num, 'is even')
}
cat('mode is', 1)
num %% 3
num
cat('mode is', 1)
if (num %% 3 == 1) {
cat('mode is', 1)
} else if (num %% 3 == 2) {
cat('mode is', 2)
} else {
cat('mode is', 0)
}
if (num %% 3 == 1) {
cat('mode is', 1)
} else if (num %% 3 == 2) {
cat('mode is', 2)
} else {
cat('mode is', 0)
}
#条件判断---顺序执行
num <- 5
if (num %% 3 == 1) {
cat('mode is', 1)
} else if (num %% 3 == 2) {
cat('mode is', 2)
} else {
cat('mode is', 0)
}
### 因为在R语言中，所有涉及到修改变量的情况，都会将变量重新复制一份，这样会
### 消耗内存和计算时间，因此在循环中修改变量会比较慢，我们用一个判断质数的例子来比较如下三种编程方法的速度
findprime <- function(x) {
if (x %in% c(2, 3, 5, 7)) return(TRUE)
if (x %% 2 == 0 | x == 1) return(FALSE)
xsqrt <-  round(sqrt(x))
xseq <- seq(from = 3, to = xsqrt, by = 2)
print(xsqrt)
print(xseq)
if (all(x %% xseq != 0)) return(TRUE)
else return(FALSE)
}
system.time({
x <- logical()
for (i in 1:10000) {
y <- findprime(i)
x <- c(x, y)
}
})
system.time({
x <- logical(10000)
for (i in 1:10000) {
y <- findprime(i)
x[i] <- y
}
})
x <- sapply(1: 1e4, findprime)
x <- sapply(1: 1e5, findprime)
system.time({
x <- logical()
for (i in 1:1e5) {
y <- findprime(i)
x <- c(x, y)
}
})
system.time({
x <- logical(1e5)
for (i in 1:10000) {
y <- findprime(i)
x[i] <- y
}
})
system.time({
x <- logical(1e5)
for (i in 1:10000) {
y <- findprime(i)
x[i] <- y
}
})
system.time({
x <- logical(1e5)
for (i in 1:1e5) {
y <- findprime(i)
x[i] <- y
}
})
#函数深入
fibonaci <- function(n) {
i <- 2
x <- 1:2
while(x[i] < n) {
x[i + 1] <- x[i - 1] + x[i]
i <- i + 1
}
x <- x[-i]
return(x)
}
SeqFi <- fibonaci(100)
SeqFi
plot(SeqFi)
SeqFi <- fibonaci(1e5)
SeqFi
plot(SeqFi)
curve(SeqFi)
plot(SeqFi)
SeqFi <- fibonaci(1e3)
SeqFi
plot(SeqFi)
# 函数内部是局部变量, 如果要修改全局变量：
x <- 10
tempfunc <- function(n) {
x <<- 1
return(x + n)
}
tempfunc(2)
x
# 可以给函数设置缺省值：
SdFunc <- function(x, type = 'sample') {
n <- length(x)
m <- mean(x)
if (type == 'sample') {
sd <- sqrt(sum((x - m)^2)/(n - 1))
}
if (type == 'population') {
sd <- sqrt(sum((x - m)^2)/(n))
}
return(sd)
}
SdFunc(1:10)
SdFunc(1:10, type = 'population')
？ plot()
? plot
SdFunc(1:10, type = 'population')
SdFunc(1:10)
SdFunc(1:10, 'jioj')
SdFunc(1:10, type = 'population')
SdFunc('hi')
SdFunc(1:10, 'hi')
SdFunc(1:10)
y <- c(1:10, 50)
y
SdFunc(y, type = 'sample', trim = 0.1)
# 可以给函数设置缺省值, 其实就类似js的默认参数, ...类似于扩展运算符：
SdFunc <- function(x, type = 'sample', ...) {
# 参数检查
stopifnot(is.numeric(x),
length(x) > 0,
type %in% c('sample', 'populattion'))
x <- x[!is.na(x)]
n <- length(x)
m <- mean(x, ...)
if (type == 'sample') {
sd <- sqrt(sum((x - m)^2)/(n - 1))
}
if (type == 'population') {
sd <- sqrt(sum((x - m)^2)/(n))
}
return(sd)
}
SdFunc(y, type = 'sample', trim = 0.1)
SdFunc(1:10, type = 'population')
# 可以给函数设置缺省值, 其实就类似js的默认参数, ...类似于扩展运算符：
SdFunc <- function(x, type = 'sample', ...) {
# 参数检查
stopifnot(is.numeric(x),
length(x) > 0,
type %in% c('sample', 'population'))
x <- x[!is.na(x)]
n <- length(x)
m <- mean(x, ...)
if (type == 'sample') {
sd <- sqrt(sum((x - m)^2)/(n - 1))
}
if (type == 'population') {
sd <- sqrt(sum((x - m)^2)/(n))
}
return(sd)
}
SdFunc(1:10, type = 'population')
SdFunc(1:10)
SdFunc(y, type = 'sample', trim = 0.1)
SdFunc(y)
SdFunc(y)
SdFunc(y, type = 'sample', trim = 0.1)
# 函数递归
Fac1 <- function(n) {
if (n == 0) return(1)
return(n * Fac1(n - 1))
}
Fac1(10)
Fac1(5)
Fac1(100)
# 递归也可以用循环来处理
Fac2 <- function(n) {
if (n == 0) return(1)
else {
res <- n
while (n > 1) {
res < res * (n - 1)
n <- n - 1
}
}
return(res)
}
Fac2(10)
# 递归也可以用循环来处理
Fac2 <- function(n) {
if (n == 0) return(1)
else {
res <- n
while (n > 1) {
res < res * (n - 1)
n <- n - 1
}
}
return(res)
}
Fac2(10)
Fac1(10)
# 递归也可以用循环来处理
Fac2 <- function(n) {
if (n == 0) return(1)
else {
res <- n
while (n > 1) {
res <- res * (n - 1)
n <- n - 1
}
}
return(res)
}
Fac2(10)
# 另一个使用递归来解决的常见的例子就是计算fabonaci数列：
system.time({
fibanaci <- function(n) {
if (n == 0) return(0)
if (n == 1) return(1)
return(fibonaci(n - 1) + fibanaci(n - 2))
}
fibanaci(30)
})
SeqFi <- fibonaci(1e3)
SeqFi
fibanaci <- function(n) {
if (n == 0) return(0)
if (n == 1) return(1)
return(fibonaci(n - 1) + fibanaci(n - 2))
}
fibanaci(30)
fibanaci(30)
# 另一个使用递归来解决的常见的例子就是计算fabonaci数列：
system.time({
fabonaci <- function(n) {
if (n == 0) return(0)
if (n == 1) return(1)
return(fabonaci(n - 1) + fabonaci(n - 2))
}
fibanaci(30)
})
# 另一个使用递归来解决的常见的例子就是计算fabonaci数列：
system.time({
fabonaci <- function(n) {
if (n == 0) return(0)
if (n == 1) return(1)
return(fabonaci(n - 1) + fabonaci(n - 2))
}
fabonaci(30)
})
print(fabonaci(30))
# 另一个使用递归来解决的常见的例子就是计算fabonaci数列：
system.time({
fabonaci <- function(n) {
if (n == 0) return(0)
if (n == 1) return(1)
return(fabonaci(n - 1) + fabonaci(n - 2))
}
fabonaci(30)
print(fabonaci(30))
})
SeqFi <- fibonaci(1e3)
SeqFi
class(SeqFi)
SeqFi
# 匿名函数
set seed(1)
m <- matrix(rnorm(100), 10, 10)
apply(m, 1, function(x) max(x) - min(x))
# 二元运算符
Prod <- 1:4 * 4:1
Prod
# 二元运算符
Prod <- 1:4 * 4:1
Prod
Prod <- '*'(1:4, 4:1)
Prod
### 二元运算符也可以自定义。例如定义一个集合运算的运算符，找出两个集合的交集：
a <- c('apple', 'banana', 'orange')
b <- c('grape', 'banana', 'orange')
'%it%' <- function(x, y) {
intersect(x, y) # 内置求交集的函数
}
a %it% b
a %in% b
'apple' %in% b
'banana' %in% b
x
x <- sample(100, 10)
x
x <- sample(100, 10)
x
x <- sample(100, 10)
x
set.seed(1)
FuncList$base(x)
# 函数式编程
### R语言是一种函数式编程语言，其本质可归纳为一句话，即函数和其它对象一样是“一等公民”。也就是说：
### 可以有名字
### 可以没名字
### 作为函数的输出
### 作为函数的输入
FuncList <- list(base = function(x) mean(x),
med = function(x) median(x),
manual = function(x) {
n <- length(x)
x <- sort(x)|c(-1, -n)|
mean(x)
})
FuncList$base(x)
FuncList$base(x)
FuncList$base(x)
FuncList
FuncList$manual(x)
FuncList$manual(x)
# 函数式编程
### R语言是一种函数式编程语言，其本质可归纳为一句话，即函数和其它对象一样是“一等公民”。也就是说：
### 可以有名字
### 可以没名字
### 作为函数的输出
### 作为函数的输入
FuncList <- list(base = function(x) mean(x),
med = function(x) median(x),
manual = function(x) {
n <- length(x)
x <- sort(x)[c(-1, -n)]
mean(x)
})
set.seed(1)
x <- sample(100, 10)
FuncList$base(x)
FuncList$manual(x)
# 函数式编程
### R语言是一种函数式编程语言，其本质可归纳为一句话，即函数和其它对象一样是“一等公民”。也就是说：
### 可以有名字
### 可以没名字
### 作为函数的输出
### 作为函数的输入
FuncList <- list(base = function(x) mean(x),
med = function(x) median(x),
manual = function(x) {
n <- length(x)
x <- sort(x)[c(-1, -n)]
print(x)
mean(x)
})
FuncList$manual(x)
# 如果要将三个函数都对x进行计算, 可以使用for循环， 或者更好的是用向量化计算
for (f in FuncList) {
print(f(x))
}
sapply(FuncList, function(f) f(x))
sapply(FuncList, function(f) f(x)) # 向量化计算
? sort
x
sort(x)
sort(x)[-1]
a <- sort(x)[-1]
a
x
sort(x)[-1, -10]
sort(x)[-1, -9]
sort(x)[-10]
sort(x)[-9]
sort(x)
sort(x)[c(-1, -2, -3)]
# replicate函数能让某个函数重复调用多遍， 这在统计中非常有用。例如生成1000个服从正态分布的随机向量，
# 然后计算其均值， 并使这个过程重复100遍
res <- replicate(100, mean(rnorm(10000)))
res
